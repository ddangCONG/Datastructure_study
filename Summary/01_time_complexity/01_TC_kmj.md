# 1.1 자료구조와 알고리즘

---

## 자료구조의 개념

- 스택 : 접시를 쌓아서 관리하는 구조
- 큐 : 맛집의 줄서기 방식
- 트리 : 조직도
- 그래프 : 지하철 노선도와 같은 구조

## 자료구조의 분류

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc36d875-7708-4d1d-a02d-b09caf47d438/5c54c4c4-76cb-48ac-991d-667fe605e232/Untitled.png)

- 선형 자료구조 : 일렬로 나열하여 저장하여 자료들 사이에 순서가 있음
    
    ex) 스택, 큐, 덱 등
    
- 비선형 자료구조 : 한 줄로 세우기 어려운 복잡한 관계의 자료
- ex) 트리(폴더, 조직도), 그래프(지도)

## 알고리즘이란?

- 자료구조 : 데이터를 표현하는 방법
    
    ex) 단어가 저장된 배열
    
- 알고리즘 : 효과적으로 문제를 해결하는 절차
    
    ex) 배열에서 원하는 단어를 효과적으로 찾기 위해 알파벳 순으로 정렬되어 있는 것을 이용
    
- 자료구조 + 알고리즘 = 프로그램

## 알고리즘의 조건

- 입력 : 0개 이상
- 출력 : 1개 이상
- 명백성 : 각 명령어의 의미가 명확해야 함
- 유한성 : 한정된 수의 단계 후 반드시 종료되어야 함
- 유효성 : 각 명령어들은 실행 가능한 연산이어야 함

# 1.2 추상 자료형(Abstract Data Type, ADT)

---

## 추상 자료형의 개념

- 어떤 자료가 있는가?
- 어떤 연산이 제공되는가?
- 어떻게 구현하는지는 정의하지 않음
    
    ex) 가방
    
    1. 가방이 다루는 데이터 : 지갑, 필통, 연필, 노트북 등
    2. 가방이 다루는 연산 : 물건을 넣기, 물건을 빼기, 물건의 개수 확인하기, 물건이 있는지 확인하기 등

<aside>
💡 사용자 프로그램에게 구현하기 위한 세부적인 방법이 아닌 간단한 인터페이스만 공개하여 쉽게 사용할 수 있도록 함

</aside>

```python
# 주요 연산 

def insert(bag, e): # 가방에 물건을 넣는 연산
	bag.append(e)

def remove(bag, e): # 가방에서 물건을 빼는 연산
	bag.remove(e)

# 도전 코딩
def numOf(bag, e):
	return bag.count(e)

# 사용자 프로그램

myBag = []

insert(myBag,'지갑') # 가방에 지갑을 넣음
insert(myBag,'휴대폰')
remove(myBag,'지갑') # 가방에서 지갑을 뺌
```

# 1.3 알고리즘 성능 분석

## 실행 시간 측정

```python
import time
myBag = []
start = time.time()

insert(myBag,'지갑')
. . .

end = time.time()
print('실행시간 : ', end-start
```

- 모듈을 활용한 시간 측정과 단점
    1. 구현 필수
    2. 동일한 조건 및 환경
    3. 동일한 데이터
    

## 알고리즘 복잡도 분석

<aside>
💡 연산 횟수를 대략적으로 계산하여 알고리즘을 구현하지 않고도 알고리즘의 효율성을 평가하는 방법

</aside>

```python
# n까지의 합을 구하는 방법

# 방법 1 : 반복 활용
calc_sum1(n)
	sum = 0 # 연산자 '=' 1번 수행
	for i in range(len(n)): # 반복 연산 무시
		sum = sum + i # 연산자 '='와 '+'가 각각 n번씩 수행
	return sum

# 방법 2 : 공식 활용
calc_sum2(n)
	sum = n * ( n+1 ) / 2 # 연산자 '=', '*', '+', '/'가 각각 1번씩 수행
	return sum
```

- 복잡도 함수 T(n) : 연산들의 실행 횟수, 입력의 크기 n에 대한 함수 형태
    
    방법_1 : T(n) = 2n + 1
    
    - 입력  크기 n에 비례하는 수의 연산 실행
    
    방법_2 : T(n) = 4
    
    - 입력의 크기 n과 관계없이 항상 같은 연산 수행

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/bc36d875-7708-4d1d-a02d-b09caf47d438/34227619-e2a4-4ed4-b5ce-13f57b7a182b/Untitled.png)

- 입력의 크기가 커질수록 방법_2가 효율적임.

## 복잡도의 점근적 표기
